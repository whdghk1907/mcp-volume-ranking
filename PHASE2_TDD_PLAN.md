# Phase 2: TDD 기반 개발 계획서

## 🧪 TDD 방법론 적용 전략

### TDD 사이클
1. **🔴 RED**: 실패하는 테스트 작성
2. **🟢 GREEN**: 테스트를 통과하는 최소한의 코드 작성
3. **🔵 REFACTOR**: 코드 품질 개선 및 최적화

### Phase 2 목표
- 나머지 5개 MCP 도구 구현
- 계층적 캐싱 시스템 구현
- 순위 계산 로직 구현
- 모든 기능의 테스트 커버리지 90% 이상 달성

---

## 📋 TDD 구현 계획

### Day 4-5: 나머지 MCP 도구 TDD 구현

#### 🔴 RED Phase
각 도구별로 실패하는 테스트 먼저 작성:

1. **거래대금 증가율 순위 도구** (`get_volume_change_ranking`)
   - 테스트: 기간별 비교 로직 검증
   - 테스트: 증가율 계산 정확성 검증
   - 테스트: 매개변수 유효성 검증

2. **투자자별 거래 순위 도구** (`get_investor_ranking`)
   - 테스트: 투자자 유형별 데이터 파싱
   - 테스트: 순매수/매도 계산 로직
   - 테스트: 영향도 계산 검증

3. **업종별 거래대금 순위 도구** (`get_sector_volume_ranking`)
   - 테스트: 업종 코드 매핑 검증
   - 테스트: 업종별 집계 로직
   - 테스트: 대표 종목 선정 로직

4. **시가총액 순위 도구** (`get_market_cap_ranking`)
   - 테스트: 시가총액 계산 검증
   - 테스트: 필터링 로직 검증
   - 테스트: 순위 변동 추적

5. **이상 거래량 감지 도구** (`get_unusual_volume`)
   - 테스트: 통계적 이상치 탐지
   - 테스트: 임계값 기반 감지
   - 테스트: 연속 이상거래일 계산

#### 🟢 GREEN Phase
각 테스트를 통과하는 최소한의 구현:
- API 클라이언트 메소드 구현
- 데이터 파싱 로직 구현
- 응답 포맷팅 구현

#### 🔵 REFACTOR Phase
- 코드 중복 제거
- 성능 최적화
- 에러 처리 강화

### Day 6-7: 캐싱 시스템 TDD 구현

#### 🔴 RED Phase
캐싱 시스템 테스트 작성:

1. **L1 캐시 (메모리, 1분)**
   - 테스트: 캐시 저장/조회 검증
   - 테스트: TTL 만료 검증
   - 테스트: 캐시 히트/미스 통계

2. **L2 캐시 (메모리, 5분)**
   - 테스트: 계층적 캐시 동작
   - 테스트: L1에서 L2로 승격
   - 테스트: 메모리 사용량 제한

3. **캐시 무효화**
   - 테스트: 패턴 기반 무효화
   - 테스트: 수동 무효화
   - 테스트: 자동 무효화

#### 🟢 GREEN Phase
- HierarchicalCache 클래스 구현
- 캐시 키 생성 로직 구현
- TTL 관리 시스템 구현

#### 🔵 REFACTOR Phase
- 메모리 효율성 개선
- 캐시 통계 정확성 향상
- 동시성 안전성 확보

### Day 8: 순위 계산 로직 TDD 구현

#### 🔴 RED Phase
고급 분석 기능 테스트 작성:

1. **집중도 계산**
   - 테스트: 상위 N개 종목 집중도
   - 테스트: 허핀달 지수 계산
   - 테스트: 집중도 변화 추적

2. **이상 거래량 탐지**
   - 테스트: Z-score 기반 탐지
   - 테스트: 이동평균 기반 비교
   - 테스트: 다중 조건 필터링

3. **회전율 계산**
   - 테스트: 유통주식수 기반 계산
   - 테스트: 자유유통주식수 적용
   - 테스트: 회전율 이상치 처리

#### 🟢 GREEN Phase
- RankingCalculator 클래스 구현
- 통계 분석 알고리즘 구현
- 이상치 탐지 로직 구현

#### 🔵 REFACTOR Phase
- 수치 계산 정확성 개선
- 성능 최적화
- 확장 가능한 구조로 개선

---

## 🎯 TDD 품질 기준

### 테스트 커버리지 목표
- **라인 커버리지**: 90% 이상
- **브랜치 커버리지**: 85% 이상
- **함수 커버리지**: 95% 이상

### 테스트 종류
1. **단위 테스트**: 개별 함수/메소드 검증
2. **통합 테스트**: 컴포넌트 간 상호작용 검증
3. **기능 테스트**: 전체 기능 시나리오 검증
4. **성능 테스트**: 응답 시간 및 메모리 사용량 검증

### 테스트 데이터 전략
- **Mock 데이터**: API 응답 시뮬레이션
- **Fixture 데이터**: 재사용 가능한 테스트 데이터
- **Property-based 테스트**: 입력 경계값 자동 생성
- **Snapshot 테스트**: 출력 형식 일관성 검증

---

## 📊 TDD 진행 상황 추적

### Day 4 목표
- [ ] `get_volume_change_ranking` TDD 완료
- [ ] `get_investor_ranking` TDD 완료

### Day 5 목표  
- [ ] `get_sector_volume_ranking` TDD 완료
- [ ] `get_market_cap_ranking` TDD 완료
- [ ] `get_unusual_volume` TDD 완료

### Day 6 목표
- [ ] L1/L2 캐시 시스템 TDD 완료
- [ ] 캐시 통계 시스템 TDD 완료

### Day 7 목표
- [ ] 캐시 무효화 시스템 TDD 완료
- [ ] 캐시 성능 최적화 TDD 완료

### Day 8 목표
- [ ] 고급 분석 기능 TDD 완료
- [ ] 전체 시스템 통합 테스트 완료

---

## 🛠️ TDD 도구 및 환경

### 테스트 프레임워크
- **pytest**: 기본 테스트 프레임워크
- **pytest-asyncio**: 비동기 테스트 지원
- **pytest-cov**: 커버리지 측정
- **pytest-mock**: 모킹 지원
- **hypothesis**: Property-based 테스트

### 품질 도구
- **black**: 코드 포맷팅
- **isort**: import 정리
- **mypy**: 타입 체킹
- **flake8**: 린팅

### CI/CD 시뮬레이션
각 단계에서 자동화된 테스트 실행:
```bash
# 테스트 실행
pytest tests/ -v --cov=src --cov-report=html

# 코드 품질 체크
black src/ tests/
isort src/ tests/
mypy src/
flake8 src/
```

---

## 🎯 성공 기준

### Phase 2 완료 조건
1. **모든 테스트 통과**: 0개 실패 테스트
2. **커버리지 달성**: 90% 이상 라인 커버리지
3. **성능 기준**: 평균 응답시간 1초 이하
4. **메모리 효율**: 캐시 메모리 사용량 100MB 이하
5. **에러율**: 1% 이하

### 검증 방법
- 자동화된 테스트 스위트 실행
- 성능 벤치마크 측정
- 메모리 사용량 프로파일링
- 실제 API 연동 테스트 (가능한 경우)

이제 TDD 방법론을 엄격히 적용하여 Phase 2를 시작하겠습니다!